% -*- root:main.tex -*-

\section{Introduction}

A cryptographic commitment scheme can be thought of as the digital equivalent to a  physical box with an associated lock. Imagine a setting where a sending party puts some message inside the box, locks it, and then sends it to a receiving party. As an immediate observation, since the box is locked the receiver cannot figure out what is inside by mere possession of the box. At some later point in time though, the sender can send the key that unlocks the box, and since the box has been in the receiver's custody the whole time it is guaranteed that the message inside is indeed the original message. Translating the above scenario to the digital world, we call the first property \textit{hiding} (receiver can't look inside the box) and the second \textit{binding} (the sender cannot change its content) and it is these properties that are realized by a cryptographic commitment scheme. We use the terms `committing to a message' as the equivalent to sending the locked box and `decomitting to a message' to mean sending the key that unlocks it.

In this white paper we present SplitCommit, an efficient and portable C++14 implementation of the recent additively homomorphic commitment scheme of \cite{DBLP:conf/tcc/FrederiksenJNT16}. In short, a commitment scheme is additively homomorphic if it allows the sending party to decommit to the sum of previously committed messages. This enhanced ability turns out not only to be useful in several applications, but also imply very low communication overhead when decommitting to a batch of messages.

\subsection{Overview of \cite{DBLP:conf/tcc/FrederiksenJNT16}}
The commitment scheme of \cite{DBLP:conf/tcc/FrederiksenJNT16} provide UC-secure additively homomorphic two-party commitments using 1-out-of-2 Oblivious Transfer (OT) as the main building block. The scheme supports committing to vectors of length $k$ over any finite field $\Field$, but the SplitCommit implementation put forward in this work only implements commitments for the binary field $\Field_2 = \myset{0,1}$ and for $k \in \myset{1,128}$. In other words the source code works solely for committing to bit-strings of length 1 or 128. Due to the binary field restriction we sometimes refer to the scheme as merely XOR-homomorphic. In addition to OT, the scheme also makes use of a linear error correction code (ECC) with parameters $[n,k,d]_\Field$ where $n$ is the codeword length, $k$ is the message length, and $d$ is the minimum distance for which we require $d \geq \ssec$ for statistical security parameter $s$.

The \cite{DBLP:conf/tcc/FrederiksenJNT16} scheme is tailored for committing to a batch of $m$ messages and intuitively works in the following way. The sender picks $m$ random messages ($k$-bit strings) and encode these using the above-mentioned ECC into $n$-bit strings. It then creates a 2-additive secret sharing of each codeword. We then view the two parts of the secret shares as two of bit matrices, where $i$'th secret sharing is located in the $i$'th column of the two matrices. For each $m$ bit \emph{row} of the two matrices, the parties perform an OT to transfer one of the two rows. As a result, for each of the $n$ bit positions in the secret shares, the receiver learns the corresponding bit value of either the first or second secret share, and it learns the same share-position for all $m$ codewords. Intuitively, by allowing the receiver to learn parts of each of the secret sharings, where which part that was learned is unknown to the sender, the probability for the sender to successfully change the value that it is committed to without being caught is negligible. Moreover, the receiver learns nothing about that committed value due to the receiver only learning disjoint parts of the secret sharing.

In order to later decommit to a committed value the sender sends both shares of the corresponding codeword to the receiver. They can then check for each position that the value reported matches the local entry-share for this value. If they all match, and the reconstructed message is a valid codeword it accepts the message, else it aborts. In order to decommit to the XOR of messages, the sender instead sends the XOR of the corresponding shares and the receiver verifies using the XOR of its local shares. This works due to the ECC and additive secret sharing both being linear operations and therefore their composition is linear as well. 

For the actual scheme more work is however needed to securely commit to the values, in particular a critical consistency check needs to be applied in order to ensure the sender sends secret shares that actually adds up to valid codewords. Also, in order to implement the above approach more efficiently, the parties run the 1-out-of-2 OTs on short $\csec$-bit strings and expand these using a pseudorandom generator (PRG), as opposed to running 1-out-of-2 OTs on the potentially much longer $m$-bit strings which would be much less efficient.